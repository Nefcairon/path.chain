full_path_chain <- function(path = ".", naming = basename){
naming <- rlang::as_function(naming)
if(dir.exists(path)){
file.list <- list.files(path, recursive = FALSE,
include.dirs = TRUE, full.names = TRUE)
file.list <- setNames(file.list, naming(file.list))
c(list('.' = path), as.list(Map(full_path_chain, file.list)))
} else {
naming(path)
}
}
naming_fun <- function(x){
if (x == ".")
"kRoot"
else
paste0("k", tools::file_path_sans_ext(basename(x)))
}
full.path.chain.2 <- full_path_chain("files", naming_fun)
full.path.chain.2 %>%
yaml::write_yaml("config.yaml")
#' @param naming naming function
#' @description `full_path_chain` represents another approach to creating chainable paths
#' In contrast to `path_chain`, this functon creates just a list with nested list with full paths as a leaves.
#' @importFrom rlang as_function
#' @examples
#' fs::dir_list()
#' chainable.path <- full_path_chain(".")
#' chainable.path
#' @return list of lists and character objects
#' @export
full_path_chain <- function(path = ".", naming = basename, root.name = "."){
naming <- rlang::as_function(naming)
if(dir.exists(path)){
file.list <- list.files(path, recursive = FALSE,
include.dirs = TRUE, full.names = TRUE)
file.list <- setNames(file.list, naming(file.list))
c(list(root.name = path), as.list(Map(full_path_chain, file.list)))
} else {
naming(path)
}
}
full.path.chain.2 <- full_path_chain("files", naming_fun, root.name = "kRoot")
full.path.chain.2 %>%
yaml::write_yaml("config.yaml")
#' @param naming naming function
#' @description `full_path_chain` represents another approach to creating chainable paths
#' In contrast to `path_chain`, this functon creates just a list with nested list with full paths as a leaves.
#' @importFrom rlang as_function
#' @examples
#' fs::dir_list()
#' chainable.path <- full_path_chain(".")
#' chainable.path
#' @return list of lists and character objects
#' @export
full_path_chain <- function(path = ".", root.name = ".", naming = basename){
naming <- rlang::as_function(naming)
if(dir.exists(path)){
file.list <- list.files(path, recursive = FALSE,
include.dirs = TRUE, full.names = TRUE)
file.list <- setNames(file.list, naming(file.list))
c(list(root.name = path), as.list(Map(full_path_chain, file.list)))
} else {
naming(path)
}
}
full.path.chain.2 <- full_path_chain("files", "kRoot", naming_fun)
full.path.chain.2 %>%
yaml::write_yaml("config.yaml")
lol <- "trollo"
list(eval(lol) = 2)
#' @param naming naming function
#' @description `full_path_chain` represents another approach to creating chainable paths
#' In contrast to `path_chain`, this functon creates just a list with nested list with full paths as a leaves.
#' @importFrom rlang as_function
#' @examples
#' fs::dir_list()
#' chainable.path <- full_path_chain(".")
#' chainable.path
#' @return list of lists and character objects
#' @export
full_path_chain <- function(path = ".", root.name = ".", naming = basename){
naming <- rlang::as_function(naming)
if(dir.exists(path)){
file.list <- list.files(path, recursive = FALSE,
include.dirs = TRUE, full.names = TRUE)
file.list <- setNames(file.list, naming(file.list))
root <- list()
root[root.name] <- path
c(root, as.list(Map(full_path_chain, file.list)))
} else {
naming(path)
}
}
full.path.chain.2 <- full_path_chain("files", "kRoot", naming_fun)
full.path.chain.2 %>%
yaml::write_yaml("config.yaml")
#' @param naming naming function
#' @description `full_path_chain` represents another approach to creating chainable paths
#' In contrast to `path_chain`, this functon creates just a list with nested list with full paths as a leaves.
#' @importFrom rlang as_function
#' @examples
#' fs::dir_list()
#' chainable.path <- full_path_chain(".")
#' chainable.path
#' @return list of lists and character objects
#' @export
full_path_chain <- function(path = ".", root.name = ".", naming = basename){
naming <- rlang::as_function(naming)
if(dir.exists(path)){
file.list <- list.files(path, recursive = FALSE,
include.dirs = TRUE, full.names = TRUE)
file.list <- setNames(file.list, naming(file.list))
root <- list()
root[root.name] <- path
call_full_path_chain <- function(x) full_path_chain(root.name = root.name,
naming    = naming)
c(root, as.list(Map(call_full_path_chain, file.list)))
} else {
naming(path)
}
}
full.path.chain.2 <- full_path_chain("files", "kRoot", naming_fun)
#' @param naming naming function
#' @description `full_path_chain` represents another approach to creating chainable paths
#' In contrast to `path_chain`, this functon creates just a list with nested list with full paths as a leaves.
#' @importFrom rlang as_function
#' @examples
#' fs::dir_list()
#' chainable.path <- full_path_chain(".")
#' chainable.path
#' @return list of lists and character objects
#' @export
full_path_chain <- function(path = ".", root.name = ".", naming = basename){
naming <- rlang::as_function(naming)
if(dir.exists(path)){
file.list <- list.files(path, recursive = FALSE,
include.dirs = TRUE, full.names = TRUE)
file.list <- setNames(file.list, naming(file.list))
root <- list()
root[root.name] <- path
call_full_path_chain <- function(x) full_path_chain(x,
root.name = root.name,
naming    = naming)
c(root, as.list(Map(call_full_path_chain, file.list)))
} else {
naming(path)
}
}
full.path.chain.2 <- full_path_chain("files", "kRoot", naming_fun)
full.path.chain.2 %>%
yaml::write_yaml("config.yaml")
?stringi::stri_trans_totitle()
naming_fun <- function(x){
paste0("k", tools::file_path_sans_ext(stringi::stri_trans_totitle(basename(x))))
}
full.path.chain.2 <- full_path_chain("files", "kRoot", naming_fun)
full.path.chain.2 %>%
yaml::write_yaml("config.yaml")
#' @param naming naming function
#' @description `full_path_chain` represents another approach to creating chainable paths
#' In contrast to `path_chain`, this functon creates just a list with nested list with full paths as a leaves.
#' @importFrom rlang as_function
#' @examples
#' fs::dir_list()
#' chainable.path <- full_path_chain(".")
#' chainable.path
#' @return list of lists and character objects
#' @export
full_path_chain <- function(path = ".", root.name = ".", naming = basename){
naming <- rlang::as_function(naming)
if(dir.exists(path)){
file.list <- list.files(path, recursive = FALSE,
include.dirs = TRUE, full.names = TRUE)
file.list <- setNames(file.list, naming(file.list))
root <- list()
root[root.name] <- path
call_full_path_chain <- function(x) full_path_chain(x,
root.name = root.name,
naming    = naming)
c(root, as.list(Map(call_full_path_chain, file.list)))
} else {
path
}
}
full.path.chain.2 <- full_path_chain("files", "kRoot", naming_fun)
full.path.chain.2 %>%
yaml::write_yaml("config.yaml")
#' @param naming naming function
#' @description `full_path_chain` represents another approach to creating chainable paths
#' In contrast to `path_chain`, this functon creates just a list with nested list with full paths as a leaves.
#' @importFrom rlang as_function
#' @examples
#' fs::dir_list()
#' chainable.path <- full_path_chain(".")
#' chainable.path
#' @return list of lists and character objects
#' @export
full_path_chain <- function(path = ".", root.name = ".", naming = basename){
naming <- rlang::as_function(naming)
if(dir.exists(path)){
file.list <- list.files(path, recursive = FALSE,
include.dirs = TRUE, full.names = TRUE)
file.list <- setNames(file.list, naming(file.list))
root <- list()
root[root.name] <- path
call_full_path_chain <- function(x) full_path_chain(x,
root.name = root.name,
naming    = naming)
c(root, as.list(Map(call_full_path_chain, file.list)))
} else {
path
}
}
devtools::install()
full.path.chain.3 <- list(dirs = full.path.chain.2)
list(dirs = full.path.chain.2) %>%
yaml::write_yaml("config.yaml")
list(kDirs = full.path.chain.2) %>%
yaml::write_yaml("config.yaml")
full_path_chain(normalizePath("files"), "kRoot", naming_fun) %>%
yaml::write_yaml("config.yaml")
path.chain <- create_path_chain("files")
library(path.chain)
path.chain <- create_path_chain("files")
print(full.path.chain)
full.path.chain %>%
yaml::write_yaml("config.yaml")
path.chain %>%
yaml::write_yaml("config.yaml")
path.chain %>%
as.list() %>%
yaml::write_yaml("config.yaml")
path.chain %>%
as.list(root.name = "kDir") %>%
list(kDirs = .) %>%
yaml::write_yaml("config.yaml")
#' @name create_path_chain
#' @title Get directory structure and create path_chain object
#' @param path Path
#' @description This function returns
#' @return path_chain object
#' @examples
#' unlink("files", recursive = TRUE)
#' chainable.path <- create_path_chain("files")
#' fs::dir_tree("files")
#' @export
create_path_chain <- function(path, naming = basename){
if(dir.exists(path)){
file.list <- list.files(path, recursive = FALSE,
include.dirs = TRUE)
file.list <- setNames(file.path(path, file.list), file.list)
path_chain(node = naming(path), as.list(Map(create_path_chain, file.list)))
} else {
path_chain(node = naming(path))
}
}
path.chain <- create_path_chain("files", naming = naming_fun)
print(full.path.chain)
path.chain$data$example1.RData
#' @name create_path_chain
#' @title Get directory structure and create path_chain object
#' @param path Path
#' @description This function returns
#' @return path_chain object
#' @examples
#' unlink("files", recursive = TRUE)
#' chainable.path <- create_path_chain("files")
#' fs::dir_tree("files")
#' @export
create_path_chain <- function(path, naming = basename){
if(dir.exists(path)){
file.list <- list.files(path, recursive = FALSE,
include.dirs = TRUE)
file.list <- setNames(file.path(path, file.list), file.list)
children <-Map(create_path_chain, file.list)
children <- setNames(children, naming(file.list))
path_chain(node = basename(path), children)
} else {
path_chain(node = basename(path))
}
}
path.chain <- create_path_chain("files", naming = naming_fun)
print(full.path.chain)
path.chain %>%
as.list(root.name = "kDir") %>%
list(kDirs = .) %>%
yaml::write_yaml("config.yaml")
path.chain %>%
as.list(root.name = "kDir") %>%
list(kDirs = .) %>%
yaml::write_yaml("config.yaml")
#' @title Convert object of type `path_chain` to list
#' @param patch.chain a path_chain object
#' @param root.name key for root directory; default: 'root.dir'
#' @examples
#' unlink("files", recursive = TRUE)
#' create_sample_dir(name = "files")
#' path.chain <- create_path_chain("files")
#' as.list(path.chain)
#' unlink("files", recursive = TRUE)
#' @export
as.list.path_chain <- function(path.chain, root.name = "root.dir"){
if (length(path.chain) == 1) {
attr(path.chain, 'node')
} else {
l <- list()
l[[root.name]] <- path.chain$.
call_as.list.path_chain <- function(x, root.name = root.name) as.list.path_chain
c(l, Map(call_as.list.path_chain, path_children(path.chain)))
}
}
path.chain <- create_path_chain("files", naming = naming_fun)
print(full.path.chain)
path.chain %>%
as.list(root.name = "kRoot") %>%
list(kDirs = .) %>%
yaml::write_yaml("config.yaml")
#' @title Convert object of type `path_chain` to list
#' @param patch.chain a path_chain object
#' @param root.name key for root directory; default: 'root.dir'
#' @examples
#' unlink("files", recursive = TRUE)
#' create_sample_dir(name = "files")
#' path.chain <- create_path_chain("files")
#' as.list(path.chain)
#' unlink("files", recursive = TRUE)
#' @export
as.list.path_chain <- function(path.chain, root.name = "root.dir"){
if (length(path.chain) == 1) {
attr(path.chain, 'node')
} else {
l <- list()
l[[root.name]] <- path.chain$.
call_as.list.path_chain <- function(x, root.name = root.name) as.list.path_chain(x, root.name = root.name)
c(l, Map(call_as.list.path_chain, path_children(path.chain)))
}
}
path.chain %>%
as.list(root.name = "kRoot") %>%
list(kDirs = .) %>%
yaml::write_yaml("config.yaml")
#' @title Convert object of type `path_chain` to list
#' @param patch.chain a path_chain object
#' @param root.name key for root directory; default: 'root.dir'
#' @examples
#' unlink("files", recursive = TRUE)
#' create_sample_dir(name = "files")
#' path.chain <- create_path_chain("files")
#' as.list(path.chain)
#' unlink("files", recursive = TRUE)
#' @export
as.list.path_chain <- function(path.chain, root.name = "root.dir"){
if (length(path.chain) == 1) {
attr(path.chain, 'node')
} else {
l <- list()
l[[root.name]] <- path.chain$.
call_as.list.path_chain <- function(x, root.name = root.name) as.list.path_chain(x, root.name = root.name)
c(l, Map(call_as.list.path_chain, path_children(path.chain)))
}
}
path.chain %>%
as.list(root.name = "kRoot") %>%
list(kDirs = .) %>%
yaml::write_yaml("config.yaml")
path.chain %>%
as.list() %>%
list(kDirs = .) %>%
yaml::write_yaml("config.yaml")
#' @title Convert object of type `path_chain` to list
#' @param patch.chain a path_chain object
#' @param root.name key for root directory; default: 'root.dir'
#' @examples
#' unlink("files", recursive = TRUE)
#' create_sample_dir(name = "files")
#' path.chain <- create_path_chain("files")
#' as.list(path.chain)
#' unlink("files", recursive = TRUE)
#' @export
as.list.path_chain <- function(path.chain, root.name = "root.dir"){
if (length(path.chain) == 1) {
attr(path.chain, 'node')
} else {
l <- list()
l[[root.name]] <- path.chain$.
call_as.list.path_chain <- function(x) as.list.path_chain(x, root.name = root.name)
c(l, Map(call_as.list.path_chain, path_children(path.chain)))
}
}
path.chain %>%
as.list(root.name = "kRoot") %>%
list(kDirs = .) %>%
yaml::write_yaml("config.yaml")
devtools::install()
#' @name create_path_chain
#' @title Get directory structure and create path_chain object
#' @param path Path
#' @description This function returns
#' @return path_chain object
#' @examples
#' unlink("files", recursive = TRUE)
#' chainable.path <- create_path_chain("files")
#' fs::dir_tree("files")
#' @export
create_path_chain <- function(path, naming = basename){
if(dir.exists(path)){
file.list <- list.files(path, recursive = FALSE,
include.dirs = TRUE)
file.list <- setNames(file.path(path, file.list), file.list)
children <-Map(create_path_chain, file.list)
children <- setNames(children, naming(file.list))
path_chain(node = basename(path), children)
} else {
path_chain(node = naming(path))
}
}
path.chain %>%
as.list(root.name = "kRoot") %>%
list(kDirs = .) %>%
yaml::write_yaml("config.yaml")
path.chain$kData$example1.RData
path.chain$kData$.
#' @name create_path_chain
#' @title Get directory structure and create path_chain object
#' @param path Path
#' @description This function returns
#' @return path_chain object
#' @examples
#' unlink("files", recursive = TRUE)
#' chainable.path <- create_path_chain("files")
#' fs::dir_tree("files")
#' @export
create_path_chain <- function(path, naming = basename){
if(dir.exists(path)){
file.list <- list.files(path, recursive = FALSE,
include.dirs = TRUE)
file.list <- setNames(file.path(path, file.list), file.list)
call_create_path_chain <-function(x) create_path_chain(x, naming = naming)
children <-Map(create_path_chain, file.list)
children <- setNames(children, naming(file.list))
path_chain(node = basename(path), children)
} else {
path_chain(node = naming(path))
}
}
path.chain <- create_path_chain("files", naming = naming_fun)
#' @name create_path_chain
#' @title Get directory structure and create path_chain object
#' @param path Path
#' @description This function returns
#' @return path_chain object
#' @examples
#' unlink("files", recursive = TRUE)
#' chainable.path <- create_path_chain("files")
#' fs::dir_tree("files")
#' @export
create_path_chain <- function(path, naming = basename){
if(dir.exists(path)){
file.list <- list.files(path, recursive = FALSE,
include.dirs = TRUE)
file.list <- setNames(file.path(path, file.list), file.list)
call_create_path_chain <- function(x) create_path_chain(x, naming = naming)
children <-Map(call_create_path_chain, file.list)
children <- setNames(children, naming(file.list))
path_chain(node = basename(path), children)
} else {
path_chain(node = naming(path))
}
}
library(path.chain)
path.chain <- create_path_chain("files", naming = naming_fun)
print(path.chain$kData$example1.RData)
path.chain$kData$kExample1
path.chain %>%
as.list(root.name = "kRoot") %>%
list(kDirs = .) %>%
yaml::write_yaml("config.yaml")
#' @name naming_k
#' @title Naming convention, which adds k prefix for each
#' @param path full path or its element
#' @importFrom tools file_path_sans_ext
#' @importFrom stringi stri_trans_totitle
#' @examples
#' naming_k("path/to/my_file.txt")
naming_k <- function(path){
paste0("k", tools::file_path_sans_ext(stringi::stri_trans_totitle(basename(path))))
}
naming_k("path/to/my_file.txt")
naming_k("path/to/myfile.txt")
chainable.path <- full_path_chain(".")
chainable.path
chainable.path <- full_path_chain(".", naming = naming_k)
chainable.path$k_Pkgdown
chainable.path$kDocs$k404
chainable.path$.
chainable.path <- full_path_chain("files", naming = naming_k)
devtools::install()
devtools::build_vignettes()
devtools::build_site()
devtools::document()
devtools::install()
devtools::build_site()
devtools::build_readme()
devtools::build_site()
devtools::build_readme()
devtools::build_site()
cars[1:2]
cars[1:2,]
cars[1:2, 1]
rbind(cbind(cars, cars), cars)
length(cars)
as.Date("2020/2/28") - as.Date("2020/3/1")
